\documentclass[11pt, oneside]{article}
\usepackage{graphicx}
\usepackage{url}
\begin{document}

\title{A Text-Editor "Dream" Interface}
\author{Michael Fraser}
\maketitle

\tableofcontents

\section{Background}
Common text editors have many of the same features, like language-specific keyword highlighting, automatic text indentation, and easy customization. These editors often use a system of menus and forms to allow the user to modify preferences, manage the file, or access additional tools. As with most applications, the text editors also allow the user to directly manipulate the shape of a session window, the location of the session window, and the positioning of session tabs. Most of the actual text writing is done by the typing of a keyboard, with no alternative forms of text input. Text editors are very commonly used by programmers, as they offer wide ranges of file types and programs do not require the unnecessary font editing capabilities of a word processor.

As all these text editors have many of the same features, they all maintain similar levels of efficiency, learnability, rememberability, errors, and satisfaction. The menus and forms that allow the users to easily find a desired command or tool allow for easy learnability of the editor. It also eliminates some need for high rememberability, as the forms and menus allow for commands to be quickly found again. The editors achieve similar levels of efficiency with the forms and menus, requiring several steps to reach each command. They also allow more experienced users to utilize increased efficiency with keyboard shortcuts. Satisfaction levels for the editors rely on the features of the editors and the ability for users to edit their preferences, and vary from editor to editor. %errors!?!?

Many aspects and features of today's common text editors would be included in a the design of an ideal text editor, but current text editors lack several features that could bring text editing to a new level. As new technologies are developed, new methods of interaction are developed that could alter the way text editors allow for text to be input to a document. Text editors could even take some features of common word processors to make their use as programming tools more effective and satisfying. 

\section{Designing a New Interface}
\subsection{Aspects from Common Text Editors}
\subsubsection{Menus and Forms}
While common text editors may not be the most ideal text editors, many features they have will be utilized in making a new interface. The menus and forms text editor's like Gedit utilize to organize commands and tools will be used in the ideal interface, as they allow for new users to easily search through all the available commands and tools. Keeping the forms and menus also allows new users to be more comfortable with the ideal text editor, as there will be a feature they recognize from other editors they may have used. 

\subsubsection{Keyboard Shortcuts}
Keyboard shortcuts offer increased efficiency with utilizing tools and evoking commands, as they eliminate the need to search through the menus and forms to find the command or tool. Being able to quickly issue a command adds to user satisfaction as well, as the user can accomplish tasks without having to move their hands away from the keyboard. The keyboard shortcuts also provide consistency between different applications, as the many keyboard shortcuts are standard with many applications.

\subsubsection{Window Sizing and Positioning on Click}
As with most applications, mouse clicks and mouse drags allow the user to modify the size of an application window, the position of the window on screen, and the organization on tabs, if applicable. This direct manipulation aspect gives the users a sense of control, increasing their satisfaction. As this feature is standard with most applications, excluding it would limit how ideal the dream design can be.

Common symbols connected with these features include slashed lines on the corner of a window, to illustrate the window being dragged into a large window size, along with the cursor changing to a symbol indicating the edge of the window is modifiable. 

\subsection{New Features}
\subsubsection{Voice Recognition and Input}
Text editors limit the forms of input that can be used to modify the content of a document. They also limit the way commands and tools are selected or evoked. The ideal text editor would allow multiple forms of input and command selection, and natural language is an interface style that common text editors have not explored deeply. This feature would allow the user to produce documents without having to utilize their hands much at all. As many devices are already equipped with built-in microphones and secondary devices are readily available for other devices, natural language input is easily accessible. 

This feature would never fully be deactivated unless the user has specifically disabled the feature, and their would instead be a form of "wait state" that the feature utilizes. During that "wait state," any voice input will be processed and words will be matched to libraries that can then be added to the document. This feature would eliminate some need of the keyboard, and provide a new form of content input that would make the application more flexible than other text editors. In a manner similar to the Xbox One Kinect system, where keywords alert the system to behave in a specific manner, this system would utilze a keyword that allows the user to say the name of a command or tool. The system would then evoke or select that command or tool for the user, with the user needing to search through menus and forms or utilize a keyboard shortcut. To ensure the keyword does not overlap with a potentially desired word input, the keyword needs to be unique to the application. For example, the Xbox One Kinect System waits for the word "Xbox" to be said, which is unique to the Xbox system. 

\subsubsection{Language Libraries and Autocorrect}
A feature that this text editor will utilize is commonly found amongst word processors: autocorrect functionality. Autocorrect features note when the user has made a typing error and fix the error automatically. This is done by comparing the word with an error to the words of a word library. The word in the library with the closest resemblence to the mispelled word is then switched in to replace the mispelled word. In the event that the resemblence of any word in the library and the mispelled word does not reach a certain threshold comparison level, the autocorrect function instead highlights the word and offers suggestions to replace the mispelled word when the user investigates the highlight. 

Autocorrecting is mostly used for natural language corrections, but libraries corresponding to programming languages can be utilized to allow this feature to apply to a wide variety of programming languages. This will allow users to build programs with greater accuracy the first time they write the program, eliminating some errors that would need to be cleaned through debugging. 

\subsubsection{Autocomplete}
An autocomplete feature will add a new level of ease when it comes to adding content. As with bash commands in a terminal, the user will have the option to ask the program to complete the word that is currently being input (when the input is from the keyboard). The autocompletions will depend on the language being written, which will be autodetected by the application or manually set by the user. To utilize the autocomplete feature, and to stay consistent with other applications with the same feature, the "Tab" button will be utilized. Tab already has a special use in indentation though, so the autocomplete shortcut will be "Shift + Tab."

Adding an autocomplete function to the text editor will eliminate some need to remember all the vocabulary of a programming language, making it easier for a user to write code efficiently. The increased efficiency, along with lowering the need to consult documentation, will improve the satisfaction users have with the application. 

%Vocal autocomplete?

\section{The Pros and Cons}
\subsection{Pros}


\subsection{Cons}


\end{document}

%\bibliography{mental.bib}{}
%\bibliographystyle{plain}

% theories, principles and guidelines
%7 stage sof action, oAI, usability metrics,
%fitt's law, tagazinni's 16, etc
% interaction styles: direct manipulation, menus forms and dialogues, command-line, natural language
% everything together: dream interface, interface that would be as good as possible
% lego exercise: affordance: objects and amterials send you signals, tell you things that help you understand what those things are for
% when it all comes together, the user should get the same picture you had
% 

